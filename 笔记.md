# 学习笔记

### 常用的汇编指令



#### 1、数据传输指令

![](E:\github\Linux_study\图片\数据传输指令.png)



#### 2、存储器访问指令

![](E:\github\Linux_study\图片\存储器访问指令.png)

```apl
LDR R0, =0X0209C004   @将寄存器地址 0X0209C004 加载到 R0 中，即 R0=0X0209C004
LDR R1, [R0]          @读取地址 0X0209C004 中的数据到 R1 寄存器中
```

```apl
LDR R0, =0X0209C004  @将寄存器地址 0X0209C004 加载到 R0 中，即 R0=0X0209C004
LDR R1, =0X20000002  @R1 保存要写入到寄存器的值，即 R1=0X20000002
STR R1, [R0]   @将 R1 中的值写入到 R0 中所保存的地址中
```

| 指令 | 功能 | 用法 |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |
|      |      |      |

[ARM架构常用汇编指令]: https://blog.csdn.net/Luckiers/article/details/128221506





### 第一个makefile文件

```makefile
led.bin:led.s
	arm-linux-gnueabihf-gcc -g -c led.s -o led.o
	arm-linux-gnueabihf-ld -Ttext 0X87800000 led.o -o led.elf
	arm-linux-gnueabihf-objcopy -O binary -S -g led.elf led.bin
	arm-linux-gnueabihf-objdump -D led.elf > led.dis
clean:
	rm -rf *.o led.bin led.elf led.dis
```



### ARM中的特殊的寄存器

在ARM体系中，一般分为四种寄存器：**通用目的寄存器**、**堆栈指针(SP)**、**连接寄存器(LR)** 以及 **程序计数器(PC)**, 其中需要着重理解后面三种寄存器。

#### 堆栈指针R13(SP)

- 每一种异常模式都有其自己独立的r13，它通常指向异常模式所专用的堆栈，也就是说五种异常模式、非异常模式（用户模式和系统模式），都有各自独立的堆栈，用不同的堆栈指针来索引。
- 当ARM进入异常模式的时候，程序就可以把一般通用寄存器压入堆栈，返回时再出栈，保证了各种模式下程序的状态的完整性。

#### 连接寄存器R14（LR）

- 保存子程序返回地址。使用BL或BLX时，跳转指令自动把返回地址放入r14中；
- 子程序通过把r14复制到PC来实现返回，通常用下列指令：MOV PC, LR；BX LR；
- 当异常发生时，异常模式的R14用来保存异常返回地址，将R14如栈可以处理嵌套中断。

#### 程序计数器R15（PC）

- PC是有读写限制的；
- 没有超过读取限制的时候，读取的值是指令的地址加上8个字节，由于ARM指令总是以字对齐的，故bit[1:0]总是00；
- 在CM3内部使用了指令流水线，读PC时返回的值是当前指令的地址+4.
- 向PC中写数据，就会引起一次程序的分支（但是不更新LR寄存器），CM3中的指令至少是半字对齐的，所以PC的LSB总是读回0。
- 在分支时，无论是直接写 PC 的值还是使用分支指令，都必须保证加载到 PC 的数值是奇数（即 LSB=1），用以表明这是在Thumb 状态下执行。
- 倘若写了 0，则视为企图转入 ARM 模式，CM3 将产生一个 fault 异常。



1) ==data段==：数据段（datasegment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。

2) ==text段==：代码段通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读,某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。

3) ==bss段==：指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文Block Started by Symbol的简称。当我们的程序有全局变量是，它是放在bss段的，由于全局变量默认初始值都是0，所有我们需要手动清bss段。



**关于中断向量表**： 中断向量表应该被放在正式代码的开头，即链接的首地址要放到中断向量表后面。



### CP15协处理器

​		CP15 协处理器一般用于存储系统管理，但是在中断中也会使用到，CP15 协处理器一共有16 个 32 位寄存器。CP15 协处理器的访问通过如下另个指令完成	：

**MRC:** 将 CP15 协处理器中的寄存器数据读到 ARM 寄存器中。

**MCR:** 将 ARM 寄存器的数据写入到 CP15 协处理器寄存器中。



==MRC 就是读 CP15 寄存器，MCR 就是写 CP15 寄存器==，MCR 指令格式如下：

`MCR{cond} p15, <opc1>, <Rt>, <CRn>, <CRm>, <opc2>`

**cond:**  指令执行的条件码，如果忽略的话就表示无条件执行。

**opc1**：协处理器要执行的操作码。

**Rt**：ARM 源寄存器，要写入到 CP15 寄存器的数据就保存在此寄存器中。

**CRn**：CP15 协处理器的目标寄存器。

**CRm**：协处理器中附加的目标寄存器或者源操作数寄存器，如果不需要附加信息就将CRm 设置为 C0，否则结果不可预测。

**opc2**：可选的协处理器特定操作码，当不需要的时候要设置为 0。



MRC 的指令格式和 MCR 一样，只不过在 MRC 指令中 Rt 就是目标寄存器，也就是从CP15 指定寄存器读出来的数据会保存在 Rt 中。而 CRn 就是源寄存器，也就是要读取的写处理器寄存器。

假如我们要将 CP15 中 C0 寄存器的值读取到 R0 寄存器中，那么就可以使用如下命令：

`MRC p15, 0, r0, c0, c0, 0`

CP15 协处理器有 16 个 32 位寄存器，c0~c15，本章来看一下 c0、c1、c12 和 c15 这四个寄存器，因为我们本章实验要用到这四个寄存器，其他的寄存器大家参考上面的两个文档即可。































